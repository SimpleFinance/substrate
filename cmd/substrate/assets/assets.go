package assets

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/SimpleFinance/substrate/cmd/substrate/assets/binaries"
	"github.com/SimpleFinance/substrate/cmd/substrate/assets/zoneconfig"
)

// SubstrateAssets represents a temporary on-disk copy of the Substrate assets, including Terraform binaries and configuration.
type SubstrateAssets struct {
	tempDir  string
	sigChan  chan os.Signal
	doneChan chan bool
}

// ExtractSubstrateAssets extracts all our assets to a temp directory and exposes access to them via helper methods.
func ExtractSubstrateAssets() (*SubstrateAssets, error) {
	result := &SubstrateAssets{}

	// create a temporary directory for binaries and config
	var err error
	result.tempDir, err = ioutil.TempDir("", "substrate-")
	if err != nil {
		return nil, fmt.Errorf("could not create temporary directory: %v", err)
	}

	// set up a signal handler to clean up on Control-C.
	result.doneChan = make(chan bool, 1)
	result.sigChan = make(chan os.Signal, 1)
	signal.Notify(result.sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		select {
		case <-result.sigChan:
			result.Cleanup()
			os.Exit(1)
		case <-result.doneChan:
		}
	}()

	// dump out all the files, cleaning up if we fail part way through
	err = extractAllAssetsInto(result.tempDir)
	if err != nil {
		result.Cleanup()
		return nil, err
	}

	return result, nil
}

// extractAllAssetsInto reads the uses the code generated by go-bindata to
// iterate through all the assets and write them into the destination directory
func extractAllAssetsInto(destDir string) error {
	for _, assetName := range binaries.AssetNames() {
		info, err := binaries.AssetInfo(assetName)
		if err != nil {
			return err
		}
		outPath := filepath.Join(destDir, "bin", info.Name())

		buf, err := binaries.Asset(assetName)
		if err != nil {
			return err
		}

		err = os.MkdirAll(filepath.Dir(outPath), 0700)
		if err != nil {
			return err
		}

		err = ioutil.WriteFile(outPath, buf, info.Mode())
		if err != nil {
			return err
		}
	}

	for _, assetName := range zoneconfig.AssetNames() {
		info, err := zoneconfig.AssetInfo(assetName)
		if err != nil {
			return err
		}
		outPath := filepath.Join(destDir, info.Name())

		buf, err := zoneconfig.Asset(assetName)
		if err != nil {
			return err
		}

		err = os.MkdirAll(filepath.Dir(outPath), 0700)
		if err != nil {
			return err
		}

		err = ioutil.WriteFile(outPath, buf, info.Mode())
		if err != nil {
			return err
		}
	}
	return nil
}

// Cleanup cleans up the temporary directory and cancels pending signal handlers
func (a *SubstrateAssets) Cleanup() {
	// reset the signal handler so we stop catching signals
	signal.Reset(os.Interrupt, syscall.SIGTERM)

	// trigger our goroutine to terminate
	a.doneChan <- true

	// clean up the temporary directory
	os.RemoveAll(a.tempDir)
}

// Path returns the absolute path to the specified file in the extracted assets
func (a *SubstrateAssets) Path(name string) string {
	return filepath.Join(a.tempDir, name)
}
